## 垃圾收集器 Garbage Collection

<p> 程序计数器、虚拟机栈、本地方法栈这3个区域会随着线程而生，并随着线程而销毁。栈中的栈帧分配多少内存基本上在类结构确定下来即编译期便可知。随着方法结束或线程结束，对应的内存自然会进行回收。

<p> 堆空间、方法区则是在运行期间才会动态创建对象，因此垃圾收集器所关注的是这两个区域对应的内存空间。


### 引用计数法

<p> 给对象添加一个引用计数器，每当引用到该对象是，计数器自增。引用失效时，引用自减。当引用计数器值为0时，代表该对象没有被引用，因此可以进行回收。该算法简单高效，但无法解决循环引用的问题。

### 可达性分析

<p> 通过一系列GC Roots对象作为起点，从这些对象开始向下搜索，搜索走过的路径称为引用链Reference Chain。当一个对象不在任一GC Roots的Reference Chain时，即GC Roots对该对象不可达时，则证明该对象不可用。

能作为GC Roots的对象包括：
- 虚拟机栈中引用的对象（栈帧的本地变量表）
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

<p> 可达性分析中不可达的对象，会经历两次标记过程才会被回收。如果对象进行可达性分析发现不再任一Reference Chain中，则会对该对象进行第一次标记。接着会判断是否需要执行finalize()方法（必须重写finalize方法且从未执行过该方法）。
<p> 当对象需要执行finalize方法时，将该对象放入F-Queue中，由虚拟机的低优先级Finalizer线程去遍历执行（尽最大努力执行，不保证执行成功，避免死循环而阻塞F-Queue队列）。
<p> 当finalize方法执行完毕后，会再次进行可达性分析，如果对象可达，则移出回收集合中。如果对象不可达，则进行二次标记，最终回收该对象内存。
<p> 注意finalize方法只会执行一次，且不推荐使用。

### 引用Reference

<p>如果reference类型的数据中存储的数值代表另一块内存的起始地址，则这块内存代表着一个引用。

- 强引用 Strong Reference

    普遍存在的引用，如
    <code> Object obj = new Object();</code>

- 软引用 Soft Reference
    
    有用但非必要的引用，系统即将发生内存溢出时才会将这部分对象列入二次回收范围内。

- 弱引用 weak Reference

    非必要的引用，被引用的对象只能生存到下一次垃圾收集发生之前。

- 虚引用 phanthom Reference

    无法通过该引用获取一个对象实例，设置虚引用的唯一目的在于对象被回收时能收到一个通知。

### 永久代（方法区）的垃圾回收

- 废弃常量

    <p> 废弃常量的回收，比如已经进入常量池的字符串”abc“，当前系统中没有任何一个String对象引用常量池中的”abc“，这时如果发生GC且必要的话，则会将该字符串清理出常量池。常量池中的类、接口、方法、字段的符号引用也与此类似。

- 无用的类

    * 该类的所有实例都已经被回收，java堆中不存在任何该类的实例。
    * 加载该类的classLoader已经被回收
    * 该类对应的java.lang.Class对象没有在任何地方被引用，即无法通过反射访问该类的任何方法。

    <p> 满足以上三个条件的类，可以被断定为无用的类，此时jvm可以进行回收。但实际上是否进行类回收则通过jvm参数进行控制。


## 垃圾回收算法

### 标记-清除 Mark-Sweep
<p> 首先标记出所有需要回收的对象，在标记完成后，统一进行内存回收。

* 缺点：标记以及清除的效率低，会产生大量不连续的内存，导致分配大对象时无法找到连续的内存而提前触发GC。

### 标记-复制 Coying
<p> 将内存划分为大小相等的两块，每次只使用其中一块。触发GC时，在标记完成后，将存活的对象复制到另一块内存中，并将当前块所有内存进行回收。

* 优点：不会产生碎片内存，实现简单高效。
* 缺点：可用内存将缩小为原来一半

### 标记-整理 Mark-Compact
<p> 复制算法在对象存活率比较高的时候，就要进行过多的复制操作，效率会变得低。在标记对象后，将所有存活对象移向内存一端，然后清理掉边界以外的内存。
